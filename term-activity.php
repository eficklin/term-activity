<?php
/**
 * Plugin Name: Term Activity
 * Plugin Description: Adds a summary of post counts by period to term meta.
 * Author: Edward Ficklin
 * Author URI: https://github.com/eficklin
 * Text Domain: term-activity
 * License: GPLv2
 * License URI: https://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 */

namespace Term_Activity;

require_once 'class-term-activity-maps.php';

define( 'LOG', '/Users/eddy/Local Sites/2022search/app/public/wp-content/plugins/term-activity/debug.log');

class TermActivity {
    /**
     * @var array
     */
    protected $updates = [];

    /**
     * @var string
     */
    protected $action_name = 'term_activity_update';

    /**
     * Meta key prefix for storing activity snapshots.
     * 
     * @var string
     */
    protected $meta_key_prefix = 'term_activity_';

    /**
     * Some lightweight security in the form of a token to verify a request
     * was generated by an instance of this class.
     * 
     * @var string
     */
    protected $request_token = 'safetyfirst';

    /**
     * Supported taxonomies.
     * 
     * @var array
     */
    protected $supported_taxonomies = [ 'category' ];

    /**
	 * Time periods for the activity snapshot.
	 *
	 * @var int[]
	 */
	protected const PERIODS = [ 3, 30, 90 ];

    /**
     * Initialization logic.
     */
    public function init() {
        // Post published/unpublished.
        add_action( 'wp_after_insert_post', [ $this, 'maybe_recalculate_publish' ], 10, 4 );

        // Term updates.
		add_action( 'added_term_relationship', [ $this, 'maybe_recalculate_terms' ], 10, 3 );
		add_action( 'deleted_term_relationships', [ $this, 'maybe_recalculate_terms' ], 10, 3 );

        // Run calculations asynchronously.
        add_action( "admin_post_nopriv_{$this->action_name}", [ $this, 'do_update' ] );
        add_action( 'shutdown', [ $this, 'do_shutdown' ] );
    }

    /**
	 * Add term ID/post type pair to the update queue, if not already there.
	 *
	 * @param int    $term_id   The term ID.
	 * @param string $post_type The post type.
	 */
    protected function add_to_updates( $term_id, $post_type ) {
        foreach ( $this->updates as $pair ) {
			if ( $term_id === $pair['term_id'] && $post_type === $pair['post_type'] ) {
				return;
			}
		}

		$this->updates[] = [
			'term_id'   => $term_id,
			'post_type' => $post_type,
		];
    }

    /**
	 * Update activity snapshots on supported terms when post published.
	 *
	 * @param string        $post_id     The post ID.
	 * @param \WP_Post      $post        The post object.
	 * @param bool          $update      Is this an update.
	 * @param null|\WP_Post $post_before The post before.
	 */
	public function maybe_recalculate_publish( $post_id, $post, $update, $post_before ) {
		if ( $post_before && $post_before->post_status === $post->post_status ) {
			return;
		}

		if ( ( $post_before && 'publish' !== $post_before->post_status ) && 'publish' !== $post->post_status ) {
			return;
		}

        $terms = wp_get_object_terms( $post_id, $this->supported_taxonomies );
        if ( ! is_array( $terms ) ) {
			return;
		}

		foreach ( $terms as $term ) {
			$this->add_to_updates( $term->term_id, $post->post_type );
		}
	}

    /**
	 * Update activity snapshots on supported terms when term (un)set.
	 *
	 * @param int       $object_id  The object ID.
	 * @param int|array $tt_ids     A single term taxonomy ID or an array of term taxonomy IDs.
	 * @param string    $taxonomy   Taxonomy slug.
	 */
	public function maybe_recalculate_terms( $object_id, $tt_ids, $taxonomy ) {
		if ( ! in_array( $taxonomy, $this->supported_taxonomies, true ) ) {
			return;
		}

		$post = get_post( $object_id );
		if ( ! $post || 'WP_Post' !== get_class( $post ) ) {
			return;
		}

		// Could be array or int depending on which hook called the function.
		if ( ! is_array( $tt_ids ) ) {
			$tt_ids = [ $tt_ids ];
		}

		// Convert term-taxonomy IDs to term IDs.
		$term_ids = array_filter(
			array_map(
				function ( $tt_id ) use ( $taxonomy ) {
					$term = get_term_by( 'term_taxonomy_id', $tt_id, $taxonomy );
					if ( $term ) {
						return $term->term_id;
					}
				},
				$tt_ids
			)
		);

		foreach ( $term_ids as $term_id ) {
			$this->add_to_updates( $term_id, $post->post_type );
		}
	}

    /**
	 * Generates the activity snapshot.
	 *
	 * @param \WP_Term $term       The term for which to calculate activity.
	 * @param string   $post_type  Post type for the calculation.
	 * @return array The activity snapshot.
	 */
	protected function calculate_snapshot( \WP_Term $term, string $post_type ) : array {
		$snapshot = [
			'generated_at' => time(),
			'periods'      => [],
		];

		// Reverse sort and get the longest period. Grab the full set of results.
		$snapshot_periods = [];
		$periods          = self::PERIODS;
		rsort( $periods );
		$period = array_shift( $periods );

		$args = [
			'post_type'              => $post_type,
			'post_status'            => 'publish',
			'tax_query'              => [
				[
					'taxonomy'         => $term->taxonomy,
					'field'            => 'term_id',
					'terms'            => $term->term_id,
					'include_children' => false,
				],
			],
			'posts_per_page'         => -1,
			'update_post_term_cache' => false,
			'update_post_meta_cache' => false,
			'no_found_rows'          => true,
            'date_query'             => [
                [ 'after' => "-{$period} day" ],
            ],
		];
		$query = new \WP_Query( $args );

		$snapshot_periods[] = [
			'days_prior' => $period,
			'count'      => count( $query->posts ),
		];

		// Find the subsets, if any, for remaining periods.
		$tz = wp_timezone();
		foreach ( $periods as $period ) {
			if ( ! $query->post_count ) {
				$snapshot_periods[] = [
					'days_prior' => $period,
					'count'      => 0,
				];
				continue;
			}

			$cutoff = new \DateTimeImmutable( "-{$period} day", $tz );
			$posts  = array_filter(
				$query->posts,
				function( $post ) use ( $cutoff, $tz ) {
					$post_date = new \DateTimeImmutable( $post->post_date, $tz );
					return $post_date > $cutoff;
				}
			);

			$snapshot_periods[] = [
				'days_prior' => $period,
				'count'      => count( $posts ),
			];
		}

		// Put periods back into ascending order.
		usort(
			$snapshot_periods,
			function( $a, $b ) {
				return ( $a['days_prior'] < $b['days_prior'] ) ? -1 : 1;
			}
		);

		$snapshot['periods'] = $snapshot_periods;
		return $snapshot;
	}

    public function do_update() {
        $verify = $_REQUEST['request_token'] === $this->request_token;
        if ( ! $verify ) {
            return;
        }

        if ( ! isset( $_REQUEST['updates'] ) || ! is_array( $_REQUEST['updates'] ) ) {
			return;
		}

        foreach( $_REQUEST['updates'] as $pair ) {
            $term = get_term( (int) $pair['term_id'] );
            if ( $term && ! is_wp_error( $term ) ) {
				$snapshot = $this->calculate_snapshot( $term, 'post' );
				update_term_meta( 
					$pair['term_id'], 
					$this->meta_key_prefix . $pair['post_type'], 
					$snapshot
				);
			}
        }
    }

    public function do_shutdown() {
        if ( ! empty( $this->updates ) ) {
            $resp = wp_remote_post(
                admin_url( '/admin-post.php' ),
                [
                    'body'      => [
                        'action'        => $this->action_name,
                        'updates'       => $this->updates,
                        'request_token' => $this->request_token,
                    ],
                    'sslverify' => false,
                    'blocking'  => false,
                ]
            );
        }
    }
}

$ta = new TermActivity();
$ta->init();
